import json
from pathlib import Path


def parse_network_results(gnmap_path: Path) -> (dict, str):
    """
    Parses the provided ping scans .gnmap file and extracts network-level data and host entries.
    Returns a tuple:
      - A dictionary with keys: router_ip, router_hostname.
      - A JSON blob (string) representing the list of hosts (each a dict with 'ip' and 'hostname').
    """
    network_data = {}
    hosts = []
    with open(gnmap_path, "r") as f:
        lines = f.readlines()

    router_ip = None
    router_hostname = None
    for line in lines:
        if line.startswith("Host:"):
            parts = line.split()
            if len(parts) >= 2:
                host_ip = parts[1]
                hostname = ""
                if len(parts) >= 3 and parts[2].startswith("(") and parts[2].endswith(")"):
                    hostname = parts[2][1:-1]
                hosts.append({"ip": host_ip, "hostname": hostname})
                if router_ip is None:
                    router_ip = host_ip
                    router_hostname = hostname

    network_data["router_ip"] = router_ip
    network_data["router_hostname"] = router_hostname
    hosts_json = json.dumps(hosts)
    return network_data, hosts_json


def parse_host_results(gnmap_path: Path) -> str:
    """
    Parses a .gnmap file generated by an -A (host scan) nmap run and extracts detailed host data.

    For each host, the parser collects:
      - ip: Host IP address.
      - hostname: The hostname if available.
      - status: Reported status (e.g., "Up").
      - ports: A list of port dictionaries (each with port, state, protocol, service, and version).
      - ignored_state: Any ignored state information.
      - os: Operating system information.
      - seq_index: The sequence index.
      - ip_id_seq: The IP ID sequence information.

    The function aggregates results if a host appears in multiple lines.

    Returns:
      A JSON string representing a list of hosts with their details.
    """
    hosts = {}

    with open(gnmap_path, "r") as f:
        for line in f:
            line = line.strip()
            if not line.startswith("Host:"):
                continue

            # split on tab
            parts = line.split("\t")
            if not parts:
                continue

            # Parse the primary host info
            host_field = parts[0][len("Host:"):].strip()
            if "(" in host_field and host_field.endswith(")"):
                ip_part, hostname_part = host_field.split("(", 1)
                ip = ip_part.strip()
                hostname = hostname_part[:-1].strip()  # remove trailing ")"
            else:
                ip = host_field
                hostname = ""

            # create or update the host entry
            if ip not in hosts:
                hosts[ip] = {
                    "ip": ip,
                    "hostname": hostname,
                    "status": "",
                    "ports": [],
                    "ignored_state": "",
                    "os": "",
                    "seq_index": "",
                    "ip_id_seq": ""
                }
            else:
                # update hostname if not already set
                if not hosts[ip]["hostname"] and hostname:
                    hosts[ip]["hostname"] = hostname

            # process remaining columns
            for part in parts[1:]:
                part = part.strip()
                if part.startswith("Status:"):
                    hosts[ip]["status"] = part[len("Status:"):].strip()
                elif part.startswith("Ports:"):
                    ports_str = part[len("Ports:"):].strip()
                    if ports_str:
                        # ports are comma separated
                        port_entries = ports_str.split(",")
                        for entry in port_entries:
                            entry = entry.strip()
                            if entry:
                                port_info = parse_port_entry(entry)
                                if port_info:
                                    hosts[ip]["ports"].append(port_info)
                elif part.startswith("Ignored State:"):
                    hosts[ip]["ignored_state"] = part[len("Ignored State:"):].strip()
                elif part.startswith("OS:"):
                    hosts[ip]["os"] = part[len("OS:"):].strip()
                elif part.startswith("Seq Index:"):
                    hosts[ip]["seq_index"] = part[len("Seq Index:"):].strip()
                elif part.startswith("IP ID Seq:"):
                    hosts[ip]["ip_id_seq"] = part[len("IP ID Seq:"):].strip()

    host_list = list(hosts.values())
    return json.dumps(host_list)


def parse_port_entry(entry: str) -> dict:
    """
    Parses a single port entry from the gnmap output.

    Expected format (after splitting by commas):
       "<port>/<state>/<protocol>//<service>//<version>/"
    For example:
       "22/open/tcp//ssh//Dropbear sshd (protocol 2.0)/"

    The function splits the entry by "/" (ignoring empty segments) and returns a dictionary with:
       - port
       - state
       - protocol
       - service (if present)
       - version (if present)

    Returns an empty dict if parsing fails.
    """
    # split by "/" and remove empty strings
    fields = [f for f in entry.split("/") if f]
    if len(fields) < 3:
        return {}

    return {
        "port": fields[0],
        "state": fields[1],
        "protocol": fields[2],
        "service": fields[3] if len(fields) > 3 else "",
        "version": fields[4] if len(fields) > 4 else ""
    }


